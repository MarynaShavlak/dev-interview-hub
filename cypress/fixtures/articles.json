[
  {
    "id": "14",
    "title": "Принципи програмування в JavaScript: KISS, DRY, YAGNI",
    "subtitle": "Джерело: https://blog.ohyr.dev/kiss-yagni-dry",
    "img": "https://img3.teletype.in/files/25/4c/254ca56d-599c-43a4-85d6-3fbf0e23d2ee.jpeg",
    "views": 501,
    "createdAt": "05.08.2022",
    "userId": "3",
    "category": [
      "IT"
    ],
    "blocks": [
      {
        "id": "1",
        "type": "TEXT",
        "title": "",
        "paragraphs": [
          "У світі програмування існує кілька ключових принципів, які допомагають створювати більш читабельний, ефективний та підтримуваний код. Давайте розглянемо деякі з них із прикладами на мові програмування JavaScript."
        ]
      },
      {
        "id": "2",
        "type": "TEXT",
        "title": "KISS (Keep It Simple, Stupid) or (Keep it Short and Simple)",
        "paragraphs": [
          "Принцип KISS стверджує, що системи мають бути максимально простими і зрозумілими. Це дозволяє зменшити кількість помилок і полегшити підтримку коду.",
          "Не треба для якоїсь маленької фічі додавати у проект цілу велику бібліотеку. Надзвичайно розповсюджено зараз, особливо на фронті - як-от з бібліотекою moment.js. Нам треба одну дату в проекті відформатувати, а ми додаємо цілу бібліотеку, тим самим додаючи цілу одну залежність, збільшуючи розмір бандлу, збільшуючи кількість потенційних вразливостей у проекті і так далі.",
          "Не варто перевантажувати інтерфейс - надмірно розбивати один метод на купу інших, виносити певний хардкод в конфігураційні файли, додавати можливість налаштування чомусь простому...\nПриклад. Є у нас бекенд, який запускається на строго визначеному порті (ну максимум додали можливість задавати порт у конфіг-файлі). І ми такі \"ну блін, це ж не зовсім зручно, давайте напишемо логіку для автоматичного знаходження першого вільного порта і будемо біндитись туди, це ж краще\". Ну зробили так. А потім адміни голову ламають, як наш бекенд порт вибирає собі, мають налаштовувати фаєрвол для всіх портів одразу і т.д. По-перше, не варто було так робити - треба було по-простому - конфіг файл і все. По-друге, якби клієнту знадобився такий автовибір порту, він би сам цю логіку на своїй стороні написав.",
          "Не потрібно оптимізовувати проект, економлячи кілька наносекунд. Швидш за все, ця оптимізація зробить з коду кашу, і він точно не буде short and simple. До цього ж відноситься і реалізація астрономічної точності математичних розрахунків на неастрономічних проектах.",
          "Що більше стрічок коду у проекті, то більше в ньому потенційних багів, тому що кількість багів у проекті прямо пропорційна кількості стрічок коду.",
          "Насправді, кожен початківець стикається з результатом \"невиконання\" цього принципу тоді, коли начитавшись розумної літератури, починає новий проект. Стільки всяких ідей крутиться в голові, треба ж зробити так, щоб у майбутньому було простіше розширяти проект, треба продумати всі моменти... Так, якщо цього не зробити, то у вас вийде Фейсбук, технічний борг у якому хрін випилиш. Але якщо упоротись - ви проект так і не закінчите. Тому варто шукати золоту середину."
        ]
      },
      {
        "id": "3",
        "type": "TEXT",
        "title": "DRY (Don't Repeat Yourself)",
        "paragraphs": [
          "Принцип DRY закликає до уникання дублювання коду шляхом використання функцій, класів або інших абстракцій.",
          "Принцип був сформований у відомій книзі \"Програміст-прагматик\" Ендрю Ханта і Дейва Томаса. Насправді, цей принцип не стільки про дублювання коду (бо про це і так каже майже будь-який інший принцип), скільки про єдине джерело даних (Single Source of Truth).",
          "Будь-яка інформація повинна мати єдине, однозначне і авторитетне представлення в системі.",
          "Безліч разів бачив, що дані в додатку дублюються просто для того, щоб було \"простіше працювати\", типу дані однакові, але зберігаються в різних форматах. Я теж коли писав свої проекти, думав: \"блін, нашо мені кожен раз конвертувати цю стрічку в мій формат, якщо можна просто в таблиці поруч нове поле зробити і туди це все класти\". Насправді, нове поле поруч з оригінальним - це ще не страшно, бо його видно. А ось коли у нас одні і ті самі дані в різних таблицях - це вже страшно. Та, насправді, навіть коли вони поруч, дуже просто забути продублювати операції для роботи з ними. У будь-якому разі, рано чи пізно ці дані розсинхронізуються, і стане погано.",
          "Так, принцип також застосовують до коду, але я хотів би тут перерахувати ті виключення, при яких цей принцип можна і треба не виконувати.",
          "Ну ось наприклад ви пишете фронт і бек - валідація. Її просто обовʼязково дублювати, це загальновідоме правило і без цього ніяк не можна, бо інакше ви або змушуєте клієнт і сервер страждати від величезної кількості запитів (якщо валідувати тільки на бекенді), або ж порушуєте найпростіші принципи компʼютерної безпеки (валідуючи лише на фронті).",
          "Також як чудовий приклад виключення з принципу DRY можна назвати компʼютерні ігри. Зазвичай у онлайн-іграх деякий код дублюють і на клієнті, і на сервері, заради оптимізації. Адже без такої оптимізації навіть гравці з відносно непоганим пінгом бачили б слайдшоу замість плавного руху персонажів, до прикладу (ну типу клієнт сам обраховує приблизні вектори руху персонажів і рухає їх, поки достовірна інформація йде з сервера, і виходить імітація відсутності затримок)."
        ]
      },
      {
        "id": "4",
        "type": "CODE",
        "code": "// Приклад DRY:\nlet usernames = ['Alice', 'Bob', 'Charlie'];\n\n// Повторення коду:\nfor (let i = 0; i < usernames.length; i++) {\n  console.log(`Hello, ${usernames[i]}!`);\n}\n\n// Покращений варіант:\nfunction greetUser(username) {\n  console.log(`Hello, ${username}!`);\n}\n\nusernames.forEach(greetUser);\n"
      },
      {
        "id": "5",
        "type": "TEXT",
        "title": "",
        "paragraphs": [
          "Тут ми замінили повторюваний цикл на виклик функції greetUser, що робить код більш читабельним та підтримуваним."
        ]
      },
      {
        "id": "6",
        "type": "TEXT",
        "title": "YAGNI (You Aren't Gonna Need It)",
        "paragraphs": [
          "Принцип YAGNI попереджає про створення функціональності, яка вам наразі не потрібна. Це дозволяє уникнути зайвого коду та складнощі в майбутньому.",
          "Можливості, які не описані у вимогах системи, не повинні бути реалізовані.",
          "Тобто коли пишемо код, треба бути впевненими, що цей код обовʼязково нам знадобиться. Якщо думаємо - що код знадобиться пізніше - негайно припиняємо. Якщо ж займаємось рефакторингом - не варто боятись видаляти сутності, що не використовуються - раніше були часи, коли ці сутності були потрібні, тепер ці часи минули.",
          "Ну і знову ж, поговоримо про реальні приклади і застосування цього принципу.",
          "1.\tЗамовник не має оплачувати те, чого він не замовляв. Навіть якщо ви думаєте, що якась штука буде йому корисною, він має про це знати ще до того, як ви почнете її писати, бо, повірте, у майбутньому це гарантовано вилізе боком.",
          "2.\tПоговоримо про вилізе боком з попереднього пункту. Ну от ви написали якусь додаткову логіку на майбутнє. Потім замовник вам дає завдання написати нову фічу, і ви такі: блін, вона ж повністю протиречить тій додатковій логіці, що я написав раніше.... І це ще ок, ви просто видалите її. Але ж може бути, що ви написали новий модуль типу на майбутнє, і вже використали його десь. Так тепер вам ще і попереднє все переписувати, перетестовувати і так далі.",
          "3.\tНаписавши нову штуку, на вас лягає зобовʼязання її підтримувати: писати тести, документацію, підганяти конфігурацію і слідкувати за помилками, пояснювати юзерам, як вашою штукою користуватись, і так далі. Воно вам треба?",
          "4.\tЯкщо проект fixed-price, а ви додали якусь нову штуку, якої не було в ТЗ, замовник з легкістю може почати вами маніпулювати: \"ой, а ви ось це зробили, але воно взагалі не так повинно працювати, допишіть будь ласка\". Таким чином, ви додали роботи, тобто витратили гроші вашої компанії, і цілком можливо навіть вивели її в мінус, тому варто чекати небажаних гостей."
        ]
      },
      {
        "id": "8",
        "type": "TEXT",
        "title": "Висновок",
        "paragraphs": [
          "Використання цих принципів дозволяє створювати більш ефективний, читабельний та підтримуваний код у JavaScript. Розуміння цих принципів допомагає програмістам покращувати свої навички та розвивати якісний софтвер."
        ]
      }
    ],
    "user": {
      "id": "3",
      "username": "manager",
      "password": "123",
      "roles": [
        "MANAGER"
      ],
      "features": {
        "isArticleRatingEnabled": false,
        "isCounterEnabled": true,
        "isAppRedesigned": false
      },
      "avatar": "https://st3.depositphotos.com/1071184/13782/v/450/depositphotos_137825710-stock-illustration-business-person-analyzing-financial-statistics.jpg"
    }
  },
  {
    "id": "testid",
    "title": "TESTING ARTICLE",
    "subtitle": "React hooks",
    "img": "https://miro.medium.com/v2/resize:fit:1400/0*5KGuaB1kovyV4EbV.png",
    "views": 1022,
    "createdAt": "26.02.2024",
    "user": {
      "id": "3",
      "username": "manager",
      "password": "123",
      "roles": [
        "MANAGER"
      ],
      "features": {
        "isArticleRatingEnabled": false,
        "isCounterEnabled": true,
        "isAppRedesigned": false
      },
      "avatar": "https://st3.depositphotos.com/1071184/13782/v/450/depositphotos_137825710-stock-illustration-business-person-analyzing-financial-statistics.jpg"
    },
    "category": ["IT"],
    "blocks": []
  },

  {
    "id": "15",
    "title": "Як працюють замикання в JavaScript",
    "subtitle": "Джерело: https://foxminded.ua/zamykannia-javascript/",
    "img": "https://i.ytimg.com/vi/S3cBIww_6os/maxresdefault.jpg",
    "views": 7656,
    "createdAt": "05.09.2023",
    "userId": "3",
    "category": [
      "IT"
    ],
    "blocks": [
      {
        "id": "1",
        "type": "TEXT",
        "title": "",
        "paragraphs": [
          "Замикання javascript можуть бути корисними в безлічі сценаріїв програмування, даючи змогу створювати приватні змінні та методи, передавати функції як аргументи, використовувати функції зворотного виклику та багато іншого. Вони є невід’ємною частиною мови JavaScript і допомагають розробникам створювати гнучкіший і ефективніший код.",
          "У наступних розділах ми детальніше розглянемо роботу замикань, способи їхнього створення та використання, а також потенційні проблеми, з якими можна зіткнутися під час їхнього використання"
        ]
      },
      {
        "id": "2",
        "type": "TEXT",
        "title": "Що це таке",
        "paragraphs": [
          "Давайте уявимо, що у нас є функція, яка живе всередині іншої. І ця внутрішня функція може бачити і використовувати змінні із зовнішньої. Ось як це може виглядати:"
        ]
      },
      {
        "id": "4",
        "type": "CODE",
        "code": "function outerFunction() {\n\n  var outerVariable = 'Привіт, я змінна із зовнішньої функції!';\n\n  function innerFunction() {\n\n    console.log(outerVariable);\n\n  }\n\n  return innerFunction;\n\n}\n\nvar myFunction = outerFunction();\n\nmyFunction(); // Виводить \"Привіт, я змінна із зовнішньої функції!\""
      },
      {
        "id": "3",
        "type": "TEXT",
        "title": "",
        "paragraphs": [
          "У цьому прикладі innerFunction є замиканням, тому що вона може отримати доступ до змінної outerVariable, яка визначена у зовнішній функції outerFunction. Навіть після того, як зовнішня функція закінчила свою роботу і повернула innerFunction, замикання все ще пам’ятає значення outerVariable і може використати його при виклику myFunction().",
          "Давайте розглянемо ще один приклад, щоб прояснити поняття замикань:"
        ]
      },
      {
        "id": "41",
        "type": "CODE",
        "code": "function counter() {\n\n  var count = 0;\n\n  function increment() {\n\n    count++;\n\n    console.log(count);\n\n  }\n\n  function decrement() {\n\n    count--;\n\n    console.log(count);\n\n  }\n\n  return {\n\n    increment: increment,\n\n    decrement: decrement\n\n  };\n\n}\n\nvar myCounter = counter();\n\nmyCounter.increment(); // Виводить 1\n\nmyCounter.increment(); // Виводить 2\n\nmyCounter.decrement(); // Виводить 1"
      },
      {
        "id": "5",
        "type": "TEXT",
        "title": "",
        "paragraphs": [
          "У цьому прикладі counter – це зовнішня функція, яка створює дві внутрішні – increment і decrement. Кожна з них має доступ до змінної count, оголошеної всередині counter. Коли ми викликаємо counter(), ми отримуємо об’єкт із двома методами increment і decrement. Ми можемо викликати ці методи, щоб збільшувати або зменшувати значення count і бачити результати в консолі.",
          "Таким чином, замикання дозволяють нам створювати функції, які запам’ятовують значення змінних, визначених у їхніх зовнішніх функціях. Це корисно для збереження стану та створення приватних змінних і методів, які недоступні ззовні. Пам’ятайте, що замикання можуть бути дуже потужним інструментом у JavaScript, і їхнє розуміння допоможе вам писати більш гнучкий та ефективний код.\n\n"
        ]
      },
      {
        "id": "6",
        "type": "TEXT",
        "title": "Створення замикань",
        "paragraphs": [
          "Замикання створюються в момент виконання коду, коли функція оголошується всередині іншої або блоку коду. Ось кілька практичних прикладів, які допоможуть вам краще зрозуміти, як це відбувається."
        ]
      },
      {
        "id": "81",
        "type": "IMAGE",
        "src": "https://cdn-ckkcn.nitrocdn.com/zFBNvlNnhjnAtIruckhWUtdrrYcfdzYJ/assets/images/source/rev-52b0cf6/foxminded.ua/wp-content/uploads/2023/09/zamikania-js-1024x576.jpg",
        "title": "Рис.1 Створення замикання"
      },
      {
        "id": "82437",
        "type": "TEXT",
        "title": "Приклад 1. Замикання з використанням аргументу функції",
        "paragraphs": []
      },
      {
        "id": "494552",
        "type": "CODE",
        "code": "function outerFunction(name) {\n\n  function innerFunction() {\n\n    console.log('Привіт, ' + name + '!');\n\n  }\n\n  return innerFunction;\n\n}\n\nvar greetJohn = outerFunction('John');\n\ngreetJohn(); // Виводить \"Привіт, John!\"\n\nvar greetAnna = outerFunction('Anna');\n\ngreetAnna(); // Виводить \"Привіт, Anna!\""
      },
      {
        "id": "855",
        "type": "TEXT",
        "title": "",
        "paragraphs": [
          "У цьому прикладі innerFunction є замиканням, яке має доступ до аргументу name, переданого у зовнішню функцію outerFunction. Коли ми викликаємо outerFunction(‘John’), ми створюємо замикання greetJohn, яке запам’ятовує значення name рівне ‘John’. Аналогічно, при виклику outerFunction(‘Anna’), ми створюємо замикання greetAnna, яке запам’ятовує значення name, що дорівнює ‘Anna’. При виклику цих замикань вони виводять привітання з відповідним ім’ям."
        ]
      },
      {
        "id": "9",
        "type": "TEXT",
        "title": "Приклад 2. Замикання з використанням локальної змінної зовнішньої функції",
        "paragraphs": []
      },
      {
        "id": "912",
        "type": "CODE",
        "code": "function counter() {\n\n  var count = 0;\n\n  function increment() {\n\n    count++;\n\n    console.log('Поточне значення: ' + count);\n\n  }\n\n  return increment;\n\n}\n\nvar myCounter = counter();\n\nmyCounter(); // Виводить \"Поточне значення: 1\"\n\nmyCounter(); // Виводить \"Поточне значення: 2\""
      },
      {
        "id": "955",
        "type": "TEXT",
        "title": "",
        "paragraphs": [
          "Тут counter – це зовнішня функція, яка оголошує локальну змінну count. Потім вона повертає внутрішню функцію increment, яка має доступ до змінної count. Коли ми викликаємо counter(), ми отримуємо замикання myCounter, яке запам’ятовує значення count і збільшує його при кожному виклику. Ми можемо викликати myCounter і бачити, як значення count збільшується.",
          "Отже, ви бачите, як просто створювати замикання в JavaScript. Вони дають змогу зберігати стан змінних і мати доступ до них усередині функцій, що робить ваш код гнучким."
        ]
      },
      {
        "id": "788",
        "type": "TEXT",
        "title": "Потенційні проблеми",
        "paragraphs": [
          "Давайте обговоримо деякі потенційні проблеми, з якими ви можете зіткнутися під час використання замикань у JavaScript. Хоча замикання є потужним інструментом, неправильне їх використання може призвести до деяких небажаних наслідків:",
          "1. Одна з найпоширеніших проблем – це витік пам’яті. Коли функція, яка є замиканням, має доступ до змінних або об’єктів, більше не потрібних, вони продовжують займати пам’ять. Щоб уникнути витоків пам’яті, важливо бути уважними під час використання замикань і переконатися, що вони не зберігають посилання на великі обсяги даних або об’єкти, які більше не потрібні. Зазвичай достатньо звільнити посилання на ці дані, щоб дозволити збирачу сміття видалити їх із пам’яті.",
          "2. Використання замикань може призвести до невеликого зниження продуктивності. Коли замикання викликається, воно повинно звернутися до своїх зовнішніх змінних, що вимагає деякого часу. У більшості випадків це непомітно, але якщо замикання викликається безліч разів у циклі або всередині критично важливої ділянки коду, процес може сповільнитися.",
          "3. Неправильне використання замикань може призвести до помилок і несподіваної поведінки коду. Наприклад, якщо не акуратно поводитися зі змінними, оголошеними всередині замикання, може виникнути конфлікт і несподівана зміна значення змінної. Важливо бути уважними і розуміти, які змінні доступні і як вони можуть бути змінені.",
          "4. Ще одна проблема – це втрата контексту виконання функції. Коли замикання передається і викликається в іншому контексті, може виникнути проблема з доступом до змінних і об’єктів, на які воно очікує. У таких випадках може знадобитися явне прив’язування контексту при передачі замикання.",
          "Важливо розуміти ці потенційні проблеми і бути обережними під час використання замикань у своєму коді. Хороша практика – це тестування і перевірка свого коду на наявність витоків пам’яті та несподіваної поведінки."
        ]
      },
      {
        "id": "9559",
        "type": "TEXT",
        "title": "Використання в реальних сценаріях",
        "paragraphs": [
          "Давайте розглянемо деякі реальні сценарії, у яких замикання можуть бути корисними. Це допоможе вам краще зрозуміти, як їх використовувати у своїх проєктах."
        ]
      },
      {
        "id": "923",
        "type": "TEXT",
        "title": "",
        "paragraphs": [
          "Приклад 1. Створення приватних змінних і методів в об’єкт"
        ]
      },
      {
        "id": "548569680",
        "type": "CODE",
        "code": "function createPerson(name) {\n\n  var age = 0;\n\n  function increaseAge() {\n\n    age++;\n\n  }\n\n  return {\n\n    getName: function() {\n\n      return name;\n\n    },\n\n    getAge: function() {\n\n      return age;\n\n    },\n\n    celebrateBirthday: function() {\n\n      increaseAge();\n\n    }\n\n  };\n\n}\n\nvar person = createPerson('John');\n\nconsole.log(person.getName()); // Виводить \"John\"\n\nconsole.log(person.getAge()); // Виводить 0\n\nperson.celebrateBirthday();\n\nconsole.log(person.getAge()); // Виводить 1"
      },
      {
        "id": "927",
        "type": "TEXT",
        "title": "",
        "paragraphs": [
          "У цьому прикладі ми створюємо об’єкт person, який має приватні змінні name і age, а також методи для отримання імені та віку (getName і getAge). Замикання дозволяє цим методам мати доступ до приватних змінних name і age. Метод celebrateBirthday викликає внутрішню функцію increaseAge, яка збільшує значення age на одиницю. Таким чином, ми можемо безпечно змінювати й отримувати значення змінних через методи об’єкта, а вони залишаються недоступними ззовні."
        ]
      },
      {
        "id": "928",
        "type": "TEXT",
        "title": "",
        "paragraphs": [
          "Приклад 2. Функції зворотного виклику (Callback functions)"
        ]
      },
      {
        "id": "412436",
        "type": "CODE",
        "code": "function fetchData(url, callback) {\n\n  // Логіка отримання даних з API\n\n  var data = '...'; // Отримані дані\n\n  callback(data);\n\n}\n\nfetchData('https://api.example.com', function(data) {\n\n  console.log('Отримані дані:', data);\n\n});"
      },
      {
        "id": "9543721",
        "type": "TEXT",
        "title": "",
        "paragraphs": [
          "У цьому прикладі функція fetchData приймає URL і функцію зворотного виклику callback. Усередині fetchData ми отримуємо дані з API і зберігаємо їх у змінній data. Потім ми викликаємо callback і передаємо їй отримані дані. Замикання тут дає змогу передавати дані між функціями та зберігати контекст виконання. У наведеному прикладі ми передаємо анонімну функцію як callback, яка виводить отримані дані в консоль.",
          "Це лише два приклади використання замикань, і є безліч інших сценаріїв, де вони можуть бути корисними. Наприклад, в асинхронних операціях, обробці подій або при створенні модульної структури коду.",
          "Використання замикань дає змогу створювати більш гнучкий і модульний код, зберігаючи приватні дані та методи, а також передаючи контекст виконання між функціями. Вони допомагають уникнути глобальних змінних і конфліктів імен, а також сприяють підвищенню безпеки та зручності використання коду"
        ]
      },
      {
        "id": "909547",
        "type": "TEXT",
        "title": "Висновок",
        "paragraphs": [
          "У цій статті ми розглянули що таке замикання js і його важливість у контексті JavaScript. Ми вивчили, як вони працюють на простих прикладах для програмістів-початківців. Також ми обговорили потенційні проблеми, включно з витоками пам’яті, і розглянули приклади використання замикань у реальних сценаріях",
          "Сподіваюся, ця стаття допомогла вам краще зрозуміти замикання в JavaScript і надихнула на створення більш якісного коду з використанням цієї потужної концепції."
        ]
      }
    ],
    "user": {
      "id": "3",
      "username": "manager",
      "password": "123",
      "roles": [
        "MANAGER"
      ],
      "features": {
        "isArticleRatingEnabled": false,
        "isCounterEnabled": true,
        "isAppRedesigned": false
      },
      "avatar": "https://st3.depositphotos.com/1071184/13782/v/450/depositphotos_137825710-stock-illustration-business-person-analyzing-financial-statistics.jpg"
    }
  },
  {
    "id": "17",
    "title": "Розбираємося з хуками в React",
    "subtitle": "Джерело: https://dou.ua/forums/topic/47858/",
    "img": "https://miro.medium.com/v2/resize:fit:900/1*f1uLCX2jrfA_zvDElGDvcQ.png",
    "views": 783,
    "createdAt": "08.03.2017",
    "userId": "3",
    "category": [
      "IT"
    ],
    "blocks": [
      {
        "id": "1",
        "type": "TEXT",
        "title": "Що таке хуки",
        "paragraphs": [
          "У React хуки — це спеціальні функції, які дозволяють нам «підключитися» (англ. hook into) до внутрішніх механізмів бібліотеки. Іншими словами, хуки — це API для внутрішнього функціоналу React. Для прикладу, стан зберігається у Fіber-дереві, до якого в нас немає прямого доступу зовні. Тому для виконання маніпуляцій зі станом нам потрібні абстракції у вигляді хуків.",
          "На момент написання цієї статті в React є 17 вбудованих хуків (два з яких ще в canary). Крім того, інші бібліотеки, такі як React Router або Redux, також впроваджують свої власні хуки.",
          "За допомогою хуків ми можемо: створити стан та отримати доступ до нього, зареєструвати побічні ефекти, отримати та зберегти DOM-вузли, отримати доступ до контексту,покращити перформанс застосунку "
        ]
      },
      {
        "id": "2",
        "type": "TEXT",
        "title": "Особливості хуків",
        "paragraphs": [
          "Як ви могли вже помітити, всі хуки починаються зі слова use. Так React відрізняє їх від звичайних функцій. Якщо ви пишете кастомні хуки (про які ми поговоримо детальніше згодом), треба обов’язково користуватися цим правилом, коли обираєте їм назву.",
          "Хуки можна викликати тільки в межах функцій. Тобто ми можемо їх використовувати в функціональних компонентах або кастомних хуках. Вони не працюють в класах.",
          "Та найцікавіша особливість хуків — це те, що їх можна використовувати тільки на найвищому рівні компонента. На практиці це означає, що ми не можемо викликати хуки всередині умов (if), циклів, інших функцій або після раннього return. Це правило забезпечує виклик хуків в одному і тому ж порядку при кожному ререндері компонента.",
          "Пропоную зануритися глибше в React для повного розуміння цієї особливості хуків. Хуки, а також пропси, список апдейтів, стейт та інші дані важливі для коректної роботи React, зберігаються у Fiber-дереві.",
          "Структура даних для збереження хуків називається зв’язаним списком, де кожен елемент має вказівник на наступний, вони йдуть ніби ланцюжком. Якщо один з використаних хуків не буде викликано під час ререндеру, це порушить порядок зв’язаного списку та призведе до некоректної роботи. Адже для ідентифікації значення певного хука використовується саме його порядок, в нас немає іншого ідентифікатора, типу назви або айді."
        ]
      },
      {
        "id": "3",
        "type": "TEXT",
        "title": "Заміна класовим методам життєвого циклу",
        "paragraphs": [
          "Хуки працюють винятково з функціональними компонентами. Але вони дозволяють реалізувати функціонал, який зазвичай використовується в класових компонентах. Особисто мені зручніше використовувати хуки, оскільки вони здаються логічними та простішими в розумінні.",
          "Класовий метод componentDidMount спрацьовує відразу після вбудови компонента в DOM-дерево. На практиці тут я зазвичай виконую початкові налаштування, такі як отримання даних з API або налаштування обробників подій.",
          "Якщо ми хочемо досягти такого ж ефекту з використанням хуків, ми можемо скористатися useEffect з порожнім масивом залежностей:"
        ]
      },
      {
        "id": "412",
        "type": "CODE",
        "code": "useEffect(() => {\n    fetchUsers();\n }, []);"
      },
      {
        "id": "33658",
        "type": "TEXT",
        "title": "",
        "paragraphs": [
          "Але справжню силу хуків можна відчути в порівнянні з методом componentDidUpdate. Цей метод у класових компонентах викликається на кожен ререндер. З хуками ми можемо досягти цього ж ефекту, передавши в масив залежностей useEfect змінні, які ми «відстежуємо», тобто при зміні яких повинна статися певна дія (викликатися колбек).",
          "Водночас ми можемо створювати стільки окремих незалежних юз ефектів, скільки нам треба, тим самим сепаруючи логіку"
        ]
      },
      {
        "id": "4645856",
        "type": "CODE",
        "code": "useEffect(() => {  \n    fetchUser(userId);\n  }, [userId]);"
      },
      {
        "id": "354585693",
        "type": "TEXT",
        "title": "",
        "paragraphs": [
          "Метод життєвого циклу componentWillUnmount спрацьовує безпосередньо перед тим, як компонент буде видалений з DOM. Я користуюсь ним для очищення таймерів, підписок або локальних даних. У функціональних компонентах це можна реалізувати за допомогою cleanup функції в useEffect. Вона спрацьовує перед кожним викликом хука (крім першого), а також перед видаленням компоненту з DOM. Якщо масив залежности пустий — ефект такий самий, як в\n\ncomponentWillUnmount."
        ]
      },
      {
        "id": "4777712",
        "type": "CODE",
        "code": "useEffect(() => {\n  return () => {\n    clearTimeout(timeoutId);\n  };\n}, []);"
      },
      {
        "id": "51256",
        "type": "TEXT",
        "title": "Кастомні хуки",
        "paragraphs": [
          "React надає нам можливість перевикористовувати логіку та створювати свої кастомні хуки. Зазвичай для цього ми робимо просту функцію, наприклад, в utils",
          "Але якщо задіяна логіка, яка в собі містить хуки, звичайна функція нам не допоможе. Адже, як ми дізналися раніше, хуки можна викликати тільки на найвищому рівні. Для цього в React і були впроваджені кастомні хуки. По суті, це такі ж функції, але в них нам дозволяється викликати інші хуки.",
          "Наприклад розглянемо створення кастомного хука для отримання даних з API. Уявімо, що в нас є кілька компонентів, які повинні витягти дані з різних ендпоінтів. Ми можемо створити простий хук, який буде мати в собі стан для даних, статус завантаження та обробку помилок:"
        ]
      },
      {
        "id": "5334756959",
        "type": "CODE",
        "code": "function useApiData(endpoint) {\n  // State to store the fetched data\n  const [data, setData] = useState(null);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n  useEffect(() => {\n    const fetchData = async () => {\n      try {\n        const response = await fetch(apiEndpoint);\n        if (!response.ok) {\n          throw new Error(`Error: ${response.status}`);\n        }\n        const result = await response.json();\n        setData(result);\n      } catch (error) {\n        setError(error.message);\n      } finally {\n        setLoading(false);\n      }\n    };\n    fetchData();\n  }, [apiEndpoint]);\n  // Return the state and loading/error information for external use\n  return { data, loading, error };\n}"
      },
      {
        "id": "904365",
        "type": "TEXT",
        "title": "",
        "paragraphs": [
          "Цим простим хуком ми зробили абстракцію за логікою fetch, і тепер нам не треба піклуватися про імплементацію. Ми просто маємо результат, а саме: дані, поточний стан загрузки та помилки.",
          "За часів класових компонентів перевикористання логіки було набагато складнішим. Розробники зазвичай користувалися патернами, такими як render props або HOC (higher-order component). Вони не були такими чистими і зрозумілими, як кастомні хуки, а також змінювали ієрархію компонентів, призводячи до так званого «пекла обгорток» (wrapper hell). Це і було однією з основних мотивацій для впровадження хуків.",
          "Обов’язковим правилом створення кастомних хуків є те, що вони завжди повинні починатися зі слова use. Також важливо, щоб в кожного хука була своя конкретна та зрозуміла мета і описова назва. Він може приймати будь-які аргументи, а також вертати будь-які дані, які потрібні для імплементації. Всередині кастомного хука ми зазвичай використовуємо один або декілька інших хукі",
          "Приклади хуків, які часто доводиться писати на практиці: useDebounce, useLocalStorage, useThrottle, useGeolocation",
          "Цей патерн перевикористання логіки користується такою популярністю, що на просторах npm є ліби з великим вибором кастомних хуків (наприклад, ліба useHooks)."
        ]
      },
      {
        "id": "148234678",
        "type": "TEXT",
        "title": "Висновки",
        "paragraphs": [
          "У цій статті ми детально розглянули концепцію хуків в React та їхні особливості. Сподіваюсь, мені вдалося довести, що хуки є потужним інструментом, бо вони дозволяють зручно працювати зі станом, побічними ефектами та іншими аспектами компонентів.",
          "Ми розглянули вбудовані хуки, які надає React, такі як useState, useEffect та інші, а також розглянули можливості їхнього використання для створення функціональних компонентів, які замінюють класові методи життєвого циклу.",
          "Особливу увагу було приділено кастомним хукам, що дозволяють перевикористовувати логіку в різних частинах застосунку. Ми розглянули приклад створення кастомного хука для отримання даних з API, показуючи, як цей підхід спрощує код та полегшує його читання.",
          "Розуміння хуків та їхніх принципів дозволяє створювати декларативний та легко читабельний код, покращуючи продуктивність та обслуговуваність проєктів."
        ]
      }
    ],
    "user": {
      "id": "3",
      "username": "manager",
      "password": "123",
      "roles": [
        "MANAGER"
      ],
      "features": {
        "isArticleRatingEnabled": false,
        "isCounterEnabled": true,
        "isAppRedesigned": false
      },
      "avatar": "https://st3.depositphotos.com/1071184/13782/v/450/depositphotos_137825710-stock-illustration-business-person-analyzing-financial-statistics.jpg"
    }
  },
  {
    "id": "18",
    "title": "REST API як спосіб спілкування компонент веб-додатків",
    "subtitle": "Джерело:https://foxminded.ua/shcho-take-rest-api/",
    "img": "https://foxminded.ua/wp-content/uploads/2023/11/chto-takoe-rest-api.webp",
    "views": 341,
    "createdAt": "08.11.2023",
    "userId": "3",
    "category": [
      "IT"
    ],
    "blocks": [
      {
        "id": "1",
        "type": "TEXT",
        "title": "",
        "paragraphs": [
          "Що таке REST API? Якщо ви новачок у світі веб-розробки, ці абревіатури можуть здатися трохи лякаючими, але не хвилюйтеся, ми розберемося в усьому по порядку. REST API – це набір правил і угод, які дають змогу веб-додаткам обмінюватися даними. У цій статті ми розглянемо основи REST API і постараємося зробити їх зрозумілими."
        ]
      },
      {
        "id": "2",
        "type": "TEXT",
        "title": "Що це таке?",
        "paragraphs": [
          "REST API – це скорочення від Representational State Transfer Application Programming Interface. Насправді, не так уже й важливо, запам’ятаєте ви цю довгу абревіатуру чи ні. Важливіше зрозуміти, що це спосіб, за допомогою якого різні компоненти веб-додатків можуть спілкуватися між собою",
          "Якщо вам коли-небудь доводилося взаємодіяти з веб-сайтом, наприклад, надсилати запит на сервер для отримання даних або надсилання даних на сервер, то ви вже стикалися з REST API. Він використовується повсюдно у веб-розробці, і розуміння його роботи є ключовою навичкою для розробників.",
          "Для кращого розуміння того, як працює rest api, уявімо, що у нас є веб-додаток. Цей додаток має дві основні частини: frontend (клієнтська частина) і backend (серверна частина).",
          "REST API слугує мостом між цими двома частинами. Він дає змогу frontend надсилати запити до backend і отримувати дані звідти. Як це відбувається?",
          "1. Запити від клієнта до сервера: коли користувач додає товар до кошика на вебсторінці (frontend), JavaScript на сторінці створює HTTP-запит і відправляє його на сервер (backend). Запит може містити інформацію про товар, його кількість та інші деталі.",
          "2. Обробка запитів на сервері: сервер, отримавши запит, використовує REST API для інтерпретації його вмісту та виконання відповідної операції. Наприклад, він може перевірити доступність товару, зменшити кількість товару на складі та створити замовлення.",
          "3. Відповідь від сервера до клієнта: після опрацювання запиту сервер створює HTTP-відповідь і надсилає її назад на клієнтську сторону. Відповідь може містити інформацію про статус операції, оновлений стан даних або інші відомості.",
          "4. Оновлення інтерфейсу на клієнті: на клієнтському боці JavaScript обробляє HTTP-відповідь і, за необхідності, оновлює користувацький інтерфейс. Наприклад, він може оновити кошик користувача, показати повідомлення про успішну покупку тощо.",
          "Цей обмін даних між frontend і backend через REST API дає змогу застосунку функціонувати гладко й ефективно. REST API визначає правила для створення, надсилання та обробки запитів і відповідей, роблячи процес взаємодії стандартизованим і надійним"
        ]
      },
      {
        "id": "55",
        "type": "TEXT",
        "title": "Основні принципи",
        "paragraphs": [
          "REST API будується на кількох ключових принципах, які роблять його ефективним і гнучким інструментом для обміну даними.",
          "1. Stateless: чому кожен HTTP-запит відбувається в повній ізоляції. REST API працює в режимі “без стану” (stateless), що означає, що кожен HTTP-запит, надісланий на сервер, містить усі необхідні дані для його обробки. Сервер не зберігає інформацію про попередні запити від клієнта. Це робить систему більш надійною та масштабованою.",
          "2. Client-Server: автономність клієнта і сервера та їхня взаємодія. REST API суворо розділяє клієнтську та серверну частини програми. Це означає, що вони можуть розвиватися незалежно одна від одної. Клієнт може бути веб-браузером, мобільним додатком або будь-яким іншим клієнтським додатком, а сервер може бути написаний будь-якою мовою програмування.",
          "3. Uniform Interface: чотири інтерфейси для досягнення однаковості. REST API спирається на чотири основні інтерфейси: ресурси, HTTP-методи (GET, POST, PUT, DELETE), представлення ресурсів (як дані подано клієнту), і посилання між ресурсами. Це створює однаковість у способі взаємодії клієнта і сервера.",
          "4. Cacheable: як кешування покращує продуктивність програми. REST API підтримує кешування, що означає, що клієнт може тимчасово зберігати дані, щоб зменшити навантаження на сервер і поліпшити продуктивність.",
          "5. Layered System: переваги шарової системи архітектури. Сервери REST API можна організувати в шари, що робить їх більш гнучкими і масштабованими. Кожен шар виконує певні функції, і їх можна додавати або видаляти без зміни клієнтського коду.",
          "6. Code on Demand: необов’язкове обмеження, що дозволяє завантажувати код клієнта. Цей принцип є необов’язковим і надає можливість серверу надсилати клієнту виконуваний код. Це рідко використовується і потребує додаткових заходів безпеки.",
          "Загалом, принципи rest api забезпечують ефективну та гнучку взаємодію між клієнтом і сервером, а також стандартизацію, надійність і стійкість системи."
        ]
      },
      {
        "id": "8",
        "type": "TEXT",
        "title": "Висновки",
        "paragraphs": [
          "Це не просто набір технічних правил, це стандарт, який дає нам змогу будувати додатки та веб-сервіси, які можуть взаємодіяти один з одним за допомогою HTTP-протоколу.",
          "Важливість цієї технології стає очевидною, коли ми говоримо про сучасну розробку. Адже REST API надає нам стандартну взаємодію між клієнтами та серверами, що полегшує інтеграцію різноманітних додатків і служб. Воно також знаходить застосування в різноманітних сучасних сервісах і додатках. З його допомогою ми можемо інтегрувати різні сервіси та отримувати доступ до багатої екосистеми.",
          "У майбутньому, REST API збереже свою актуальність. Зі зростанням мікросервісної архітектури, збільшенням кількості пристроїв IoT і поліпшенням методів безпеки, REST API продовжуватиме відігравати ключову роль у світі розробки.",
          "Отже, розуміння та вміння правильно використовувати REST API залишаються важливими навичками для розробників, можна сказати, що це – невід’ємна частина сучасної розробки програмного забезпечення."
        ]
      }
    ],
    "user": {
      "id": "3",
      "username": "manager",
      "password": "123",
      "roles": [
        "MANAGER"
      ],
      "features": {
        "isArticleRatingEnabled": false,
        "isCounterEnabled": true,
        "isAppRedesigned": false
      },
      "avatar": "https://st3.depositphotos.com/1071184/13782/v/450/depositphotos_137825710-stock-illustration-business-person-analyzing-financial-statistics.jpg"
    }
  }

]
